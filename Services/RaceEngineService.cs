using System.Timers;
using KeibaOps.Models;

namespace KeibaOps.Services;

public class レース運用サービス : IDisposable
{
    private System.Timers.Timer _ループタイマー;
    public レース 現在のレース { get; private set; } = new();
    private readonly List<レース> _予定レースリスト = new();
    public event Action? レース状態変更時;
    public event Action<レース>? レース切替時;
    public event Action<レース>? レース終了時;

    private Random _乱数 = new Random();
    private 馬個体管理サービス _個体管理;
    private const int 予定レース数 = 3;

    public レース運用サービス(馬個体管理サービス 個体管理)
    {
        _個体管理 = 個体管理;
        現在のレース = レース生成();
        予定レース補充();
        状態通知();
        レース切替時?.Invoke(現在のレース);
        _ループタイマー = new System.Timers.Timer(100); // 10 ticks per second
        _ループタイマー.Elapsed += ゲームループ;
        _ループタイマー.Start();
    }

    public IReadOnlyList<レース> 予定レース一覧 => _予定レースリスト;
    public レース? 次のレース => _予定レースリスト.FirstOrDefault();

    private void 予定レース補充()
    {
        while (_予定レースリスト.Count < 予定レース数)
        {
            _予定レースリスト.Add(レース生成());
        }
    }

    private レース レース生成()
    {
        // ランダムにレースクラスを決定
        var r = _乱数.NextDouble();
        競走馬クラス クラス;
        string レース名サフィックス = "";
        レースグレード グレード = レースグレード.一般;
        
        if (r < 0.4) { クラス = 競走馬クラス.未勝利; レース名サフィックス = "未勝利戦"; }
        else if (r < 0.6) { クラス = 競走馬クラス.一勝クラス; レース名サフィックス = "1勝クラス"; }
        else if (r < 0.8) { クラス = 競走馬クラス.二勝クラス; レース名サフィックス = "2勝クラス"; }
        else if (r < 0.9) { クラス = 競走馬クラス.三勝クラス; レース名サフィックス = "3勝クラス"; }
        else 
        { 
            クラス = 競走馬クラス.オープン; 
            if(_乱数.NextDouble() > 0.5) 
            {
                レース名サフィックス = "G1 天皇賞"; // 仮
                グレード = レースグレード.G1;
            }
            else 
            {
                レース名サフィックス = "オープン特別";
            }
        }

        // コース設定
        var rCourse = _乱数.NextDouble();
        コース種別 コース;
        if (rCourse < 0.5) コース = コース種別.芝;
        else if (rCourse < 0.9) コース = コース種別.ダート;
        else if (rCourse < 0.98) コース = コース種別.障害;
        else コース = コース種別.サイバー空間;
        
        // サイバー空間なら名前を変える
        if (コース == コース種別.サイバー空間) レース名サフィックス = "電脳賞";

        var 新レース = new レース
        {
            レース名 = $"第{DateTime.Now.Ticks % 1000}回 {レース名サフィックス}",
            グレード = グレード,
            クラス = クラス,
            コース = コース,
            距離 = _乱数.Next(3, 8) * 400, // 1200m to 2800m
            状態 = レース状態.投票受付中
        };

        // 個体管理サービスから出走馬を選出 (8頭)
        // プレイヤー枠を空けるため、最初は7頭にする？
        // いや、とりあえず8頭埋めて、プレイヤーが入るときに1頭弾き出す方式にしよう。
        var 候補馬 = _個体管理.出走馬選出(クラス, 8);
        
        foreach(var 馬 in 候補馬)
        {
            新レース.出走馬リスト.Add(馬);
            新レース.各馬の進捗[馬.Id] = 0;
        }

        return 新レース;
    }

    public bool 出走登録(競走馬 自分の馬)
    {
        var 対象レース = 次のレース;
        if (対象レース == null) return false;
        if (対象レース.状態 != レース状態.投票受付中) return false;
        if (対象レース.出走馬リスト.Any(h => h.Id == 自分の馬.Id)) return false; // 既に登録済み
        
        // クラスチェック
        bool クラスOK = false;
        
        // 1. 完全一致
        if (自分の馬.クラス == 対象レース.クラス) クラスOK = true;
        // 2. 新馬 -> 未勝利 はOK
        if (自分の馬.クラス == 競走馬クラス.新馬 && 対象レース.クラス == 競走馬クラス.未勝利) クラスOK = true;
        // 3. オープン -> G1 はOK
        if (自分の馬.クラス == 競走馬クラス.オープン && 対象レース.グレード == レースグレード.G1) クラスOK = true;

        if (!クラスOK) return false;

        // 枠があるか？なければNPCを1頭除外
        if (対象レース.出走馬リスト.Count >= 8)
        {
            var 除外馬 = 対象レース.出走馬リスト.Last(); // 末尾（ランダム選出なので誰でもいい）
            対象レース.出走馬リスト.Remove(除外馬);
            対象レース.各馬の進捗.Remove(除外馬.Id);
        }

        対象レース.出走馬リスト.Add(自分の馬);
        対象レース.各馬の進捗[自分の馬.Id] = 0;
        
        状態通知();
        return true;
    }
    
    private int _投票待機ティック = 0; 
    private const int 投票期間ティック = 200;
    private int _回復ティック = 0;
    
    public int 投票残り秒
    {
        get
        {
            if (現在のレース.状態 != レース状態.投票受付中) return 0;
            int 残りティック = Math.Max(0, 投票期間ティック - _投票待機ティック);
            return (int)Math.Ceiling(残りティック / 10.0);
        }
    }

    private void ゲームループ(object? sender, ElapsedEventArgs e)
    {
        // 10秒に1回、全頭の疲労回復
        if (++_回復ティック >= 100) 
        {
            _個体管理.全頭疲労回復();
            _回復ティック = 0;
        }

        if (現在のレース.状態 == レース状態.投票受付中)
        {
            _投票待機ティック++;
            if (_投票待機ティック > 投票期間ティック)
            {
                現在のレース.状態 = レース状態.出走中;
                _投票待機ティック = 0;
                状態通知();
            }
            else if (_投票待機ティック % 10 == 0)
            {
                状態通知();
            }
        }
        else if (現在のレース.状態 == レース状態.出走中)
        {
            bool 全馬ゴール = true;
            var 出走馬 = 現在のレース.出走馬リスト;
            var 距離 = 現在のレース.距離;
            var 現在距離ById = 出走馬.ToDictionary(
                h => h.Id,
                h => Math.Max(0, Math.Min(1.0, 現在のレース.各馬の進捗[h.Id])) * 距離
            );
            var 順位リスト = 出走馬
                .OrderByDescending(h => 現在距離ById[h.Id])
                .ToList();
            var 順位ById = 順位リスト
                .Select((h, i) => new { h.Id, Index = i })
                .ToDictionary(x => x.Id, x => x.Index);

            foreach (var 馬 in 現在のレース.出走馬リスト)
            {
                double 現在位置 = 現在のレース.各馬の進捗[馬.Id];
                if (現在位置 < 1.0)
                {
                    全馬ゴール = false;
                    
                    // 速度計算 (m/s)
                    // 基本スピード(15m/s) + 能力値補正(0-100 -> 0-5m/s) + 乱数
                    double リアル秒速 = 15.0 + (馬.スピード / 20.0) + ((_乱数.NextDouble() - 0.5) * 2.0);
                    
                    // 脚質補正 (レース展開に影響)
                    // 0.0-0.5: 序盤 (逃げ有利)
                    // 0.5-0.8: 中盤 (位置取り)
                    // 0.8-1.0: 終盤 (差し・追込有利)
                    double 脚質補正 = 1.0;
                    double p = 現在位置;

                    switch (馬.脚質)
                    {
                        case 脚質.逃げ:
                            if (p < 0.5) 脚質補正 = 1.05; // 序盤速い
                            else if (p < 0.8) 脚質補正 = 0.97; // 中盤で失速
                            else 脚質補正 = 0.90; // 終盤タレる
                            break;
                        case 脚質.先行:
                            if (p < 0.5) 脚質補正 = 1.02;
                            else if (p < 0.8) 脚質補正 = 0.99;
                            else 脚質補正 = 0.97; // やや失速
                            break;
                        case 脚質.差し:
                            if (p < 0.5) 脚質補正 = 0.95; // 序盤抑える
                            else if (p < 0.8) 脚質補正 = 1.04; // 徐々に進出
                            else 脚質補正 = 1.12; // 終盤速い
                            break;
                        case 脚質.追込:
                            if (p < 0.5) 脚質補正 = 0.90; // 後方待機
                            else if (p < 0.8) 脚質補正 = 1.08; // まくり
                            else 脚質補正 = 1.20; // 豪脚
                            break;
                    }

                    // 巡航・位置取り・隊列 (脚質が活きるように調整)
                    int 順位 = 順位ById[馬.Id];
                    int 参加頭数 = Math.Max(1, 出走馬.Count - 1);
                    double 現在順位率 = 順位 / (double)参加頭数; // 0:先頭, 1:最後方
                    double 目標順位率 = 馬.脚質 switch
                    {
                        脚質.逃げ => 0.1,
                        脚質.先行 => 0.3,
                        脚質.差し => 0.65,
                        _ => 0.85
                    };
                    double 位置取り補正 = 1.0 + Math.Clamp(目標順位率 - 現在順位率, -0.5, 0.5) * 0.08;

                    // 脚質の意図的な前後差（序盤は能力より隊列を優先）
                    double 序盤意図補正 = 1.0;
                    if (p < 0.35)
                    {
                        if (馬.脚質 == 脚質.逃げ)
                        {
                            序盤意図補正 = 1.10; // 低能力でも先頭に立ちやすく
                        }
                        else if (馬.脚質 == 脚質.追込)
                        {
                            序盤意図補正 = 0.88; // わざと後方待機
                        }
                        else if (馬.脚質 == 脚質.差し)
                        {
                            序盤意図補正 = 0.94;
                        }
                    }

                    // 終盤での反動（逃げは失速、追込は解放）
                    double 終盤意図補正 = 1.0;
                    if (p > 0.78)
                    {
                        if (馬.脚質 == 脚質.逃げ) 終盤意図補正 = 0.88;
                        else if (馬.脚質 == 脚質.追込) 終盤意図補正 = 1.12;
                        else if (馬.脚質 == 脚質.差し) 終盤意図補正 = 1.07;
                    }

                    double スタミナ補正 = 1.0 + ((馬.スタミナ - 50) / 500.0);
                    if (p > 0.7 && 馬.スタミナ < 40) スタミナ補正 -= 0.04;

                    // 追込は序盤温存し、終盤にスタミナを吐き出す
                    double 温存補正 = 1.0;
                    if (馬.脚質 == 脚質.追込)
                    {
                        if (p < 0.35) 温存補正 = 0.95;
                        else if (p > 0.75) 温存補正 = 1.05;
                    }

                    // スリップストリーム：前を走る馬が近いほど微加速
                    double スリップストリーム補正 = 1.0;
                    if (順位 > 0)
                    {
                        var 直前馬 = 順位リスト[順位 - 1];
                        double ギャップ = 現在距離ById[直前馬.Id] - 現在距離ById[馬.Id];
                        if (ギャップ > 0 && ギャップ < 7.0)
                        {
                            スリップストリーム補正 = 1.0 + ((7.0 - ギャップ) / 7.0) * 0.03;
                        }
                    }

                    // ソラ：大きく抜け出すと気を抜きがち（終盤は解除）
                    double ソラ補正 = 1.0;
                    if (順位 == 0 && 順位リスト.Count > 1)
                    {
                        var 二番手 = 順位リスト[1];
                        double 先頭差 = 現在距離ById[順位リスト[0].Id] - 現在距離ById[二番手.Id];
                        if (先頭差 > 8.0 && p < 0.85)
                        {
                            ソラ補正 = 0.97;
                        }
                    }

                    // コーナー区間はわずかに減速
                    double コーナー補正 = (p > 0.42 && p < 0.52) || (p > 0.72 && p < 0.82) ? 0.97 : 1.0;

                    // ゲーム的倍速 (20秒で2000m走る -> 100m/s)
                    double ゲーム内秒速 = リアル秒速 * 5.5
                        * 脚質補正
                        * 位置取り補正
                        * 序盤意図補正
                        * 終盤意図補正
                        * スタミナ補正
                        * 温存補正
                        * スリップストリーム補正
                        * ソラ補正
                        * コーナー補正;

                    // 1フレーム(0.1s)の移動距離
                    double 移動距離m = ゲーム内秒速 * 0.1;

                    double 進捗加算 = 移動距離m / 現在のレース.距離;

                    現在のレース.各馬の進捗[馬.Id] += 進捗加算;
                    
                    if (現在のレース.各馬の進捗[馬.Id] >= 1.0)
                    {
                        現在のレース.各馬の進捗[馬.Id] = 1.0; // 表示用にクランプ
                        
                        // ゴール判定
                        if (!現在のレース.着順.Contains(馬.Id))
                        {
                            現在のレース.着順.Add(馬.Id);
                        }
                    }
                }
            }

            if (全馬ゴール)
            {
                現在のレース.状態 = レース状態.終了;

                // 勝者判定 (着順の1番目)
                var 勝者Id = 現在のレース.着順.FirstOrDefault();
                var 勝者 = 現在のレース.出走馬リスト.FirstOrDefault(h => h.Id == 勝者Id);

                // 疲労蓄積と最終出走
                foreach(var 馬 in 現在のレース.出走馬リスト)
                {
                    馬.疲労 = Math.Min(100, 馬.疲労 + 30);
                    馬.最終出走時刻 = DateTime.Now;
                    馬.出走数++;
                    
                    if (勝者 != null && 馬.Id == 勝者.Id)
                    {
                        馬.勝利数++;
                        馬.獲得賞金 += 1000000; // 仮の賞金
                        
                        // 昇級ロジック
                        if (馬.クラス == 競走馬クラス.新馬 || 馬.クラス == 競走馬クラス.未勝利) 馬.クラス = 競走馬クラス.一勝クラス;
                        else if (馬.クラス == 競走馬クラス.一勝クラス) 馬.クラス = 競走馬クラス.二勝クラス;
                        else if (馬.クラス == 競走馬クラス.二勝クラス) 馬.クラス = 競走馬クラス.三勝クラス;
                        else if (馬.クラス == 競走馬クラス.三勝クラス) 馬.クラス = 競走馬クラス.オープン;
                    }
                }

                レース終了時?.Invoke(現在のレース);
                
                // 次のレースへ
                Task.Delay(5000).ContinueWith(_ => 次のレースへ());
            }
            状態通知();
        }
    }

    private void 次のレースへ()
    {
        if (_予定レースリスト.Count == 0)
        {
            _予定レースリスト.Add(レース生成());
        }

        現在のレース = _予定レースリスト[0];
        _予定レースリスト.RemoveAt(0);
        _投票待機ティック = 0;
        予定レース補充();

        状態通知();
        レース切替時?.Invoke(現在のレース);
    }



    private void 状態通知() => レース状態変更時?.Invoke();

    public void Dispose()
    {
        _ループタイマー?.Stop();
        _ループタイマー?.Dispose();
    }
}
