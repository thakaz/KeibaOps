@implements IDisposable
@inject レース運用サービス 運用
@inject 実況サービス 実況

<MudPaper Class="pa-4 mb-4" Elevation="3">
    <MudStack Row="true" AlignItems="AlignItems.Center" Class="mb-4">
        <MudText Typo="Typo.h5">@運用.現在のレース.レース名</MudText>
        <MudChip T="string" Color="@(運用.現在のレース.グレード == レースグレード.G1 ? Color.Error : Color.Primary)" Size="Size.Small">@運用.現在のレース.グレード</MudChip>
        <MudChip T="string" Variant="Variant.Outlined" Size="Size.Small">@運用.現在のレース.コース</MudChip>
        <MudChip T="string" Variant="Variant.Outlined" Size="Size.Small">@運用.現在のレース.距離 m</MudChip>
    </MudStack>
    
    <!-- Live Commentary Box -->
    <MudPaper Class="pa-3 mb-2 shade-entry" Style="background-color: #f5f5f5; border-left: 4px solid #1E88E5;">
        <MudStack Row="true" AlignItems="AlignItems.Center">
            <MudIcon Icon="@Icons.Material.Filled.Mic" Color="Color.Primary" />
            <MudText Typo="Typo.subtitle1" Style="font-weight: bold;">@実況.実況生成(運用.現在のレース)</MudText>
        </MudStack>
    </MudPaper>

    <MudText Typo="Typo.body2" Class="mb-4">状態: @運用.現在のレース.状態</MudText>

    @if (運用.現在のレース.状態 == レース状態.投票受付中)
    {
        <MudAlert Severity="Severity.Info">投票受付中！まもなく出走します。</MudAlert>
    }
    
    <div class="race-track" style="position: relative; height: 400px; background-color: @(運用.現在のレース.コース == コース種別.サイバー空間 ? "#000" : (運用.現在のレース.コース == コース種別.ダート ? "#8B4513" : "#2E7D32")); border-radius: 8px; overflow: hidden; margin-top: 20px;">
        @if(運用.現在のレース.コース == コース種別.サイバー空間)
        {
            <div style="position: absolute; width: 100%; height: 100%; background: linear-gradient(0deg, transparent 24%, rgba(0, 255, 0, .3) 25%, rgba(0, 255, 0, .3) 26%, transparent 27%, transparent 74%, rgba(0, 255, 0, .3) 75%, rgba(0, 255, 0, .3) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(0, 255, 0, .3) 25%, rgba(0, 255, 0, .3) 26%, transparent 27%, transparent 74%, rgba(0, 255, 0, .3) 75%, rgba(0, 255, 0, .3) 76%, transparent 77%, transparent); background-size: 50px 50px;"></div>
        }

        <div style="position: absolute; left: 8%; right: 8%; top: 0; bottom: 0;">
            <!-- Finish Line -->
            <div style="position: absolute; right: 0; top: 0; bottom: 0; width: 4px; background-color: white; z-index: 1;"></div>

            @{
                var topMap = 走行トップ位置を算出();
            }

            @foreach (var 馬 in 運用.現在のレース.出走馬リスト)
            {
                var 進捗 = 運用.現在のレース.各馬の進捗.ContainsKey(馬.Id) ? 運用.現在のレース.各馬の進捗[馬.Id] * 100 : 0; // 0 to 100% width
                var 横位置 = 運用.現在のレース.各馬の横位置.ContainsKey(馬.Id) ? 運用.現在のレース.各馬の横位置[馬.Id] : 0.5;
                var 上位置 = topMap.TryGetValue(馬.Id, out var t) ? t : 20 + (横位置 * 320);

                <div style="position: absolute; left: 0; right: 0; top: @(上位置)px; height: 40px; transition: top 0.2s ease;">
                    <div style="position: absolute; left: @(進捗)% ; transform: translateX(-100%); display: flex; align-items: center; gap: 8px; transition: left 0.1s linear; white-space: nowrap; flex-direction: row-reverse;">
                        <MudIcon Icon="@Icons.Material.Filled.SportsScore" Style="@($"color: {馬.毛色}; font-size: 30px;")" />
                        <MudText Typo="Typo.caption" Style="color: white; white-space: nowrap;">@馬.名前</MudText>
                    </div>
                </div>
            }
        </div>
    </div>
</MudPaper>

@code {
    protected override void OnInitialized()
    {
        運用.レース状態変更時 += 状態変更処理;
    }

    private void 状態変更処理()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        運用.レース状態変更時 -= 状態変更処理;
    }

    private Dictionary<string, double> 走行トップ位置を算出()
    {
        const double trackHeight = 400;
        const double margin = 20;
        const double minGap = 34;

        var list = 運用.現在のレース.出走馬リスト
            .Select(h =>
            {
                var 横位置 = 運用.現在のレース.各馬の横位置.ContainsKey(h.Id) ? 運用.現在のレース.各馬の横位置[h.Id] : 0.5;
                var ideal = margin + (横位置 * (trackHeight - (margin * 2)));
                return new { h.Id, Ideal = ideal };
            })
            .OrderBy(x => x.Ideal)
            .ToList();

        var result = new Dictionary<string, double>();
        double prev = double.NegativeInfinity;
        foreach (var item in list)
        {
            var top = item.Ideal;
            if (top - prev < minGap) top = prev + minGap;
            result[item.Id] = top;
            prev = top;
        }

        double maxTop = trackHeight - margin;
        double overflow = result.Values.Max() - maxTop;
        if (overflow > 0)
        {
            foreach (var key in result.Keys.ToList())
            {
                result[key] = Math.Max(margin, result[key] - overflow);
            }
        }

        return result;
    }

}
